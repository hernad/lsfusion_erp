MODULE Item;

REQUIRE System, Stock, Sku, Hierarchy, Barcode, PriceListType, PriceListCalc;

// ------------------------------------ Product classifier ---------- ----------------- //

CLASS ItemGroup 'Product group': SkuGroup;
TABLE itemGroup (ItemGroup);

@defineExternalizable (itemGroup, STRING [100]);
@defineNumeratedID (ItemGroup, 'Product Groups');

GROUP paramsItemGroup 'Parameters': base;

extId 'Code' = DATA STRING [100] (ItemGroup);
overId 'Code' (ItemGroup g) = OVERRIDE extId (g), id (g);

name 'Name' = DATA ISTRING [250] (ItemGroup) IN base CHARWIDTH 20;
order 'Order' = DATA INTEGER (ItemGroup) CHARWIDTH 2 IN paramsItemGroup;

name(ItemGroup group) += name(group) IF group IS ItemGroup;
order(ItemGroup group) += order(group) IF group IS ItemGroup;
id(ItemGroup group) += id(group) IF group IS ItemGroup;

TABLE itemGroupItemGroup (ItemGroup, ItemGroup);
@defineHierarchy (itemGroup);
@defineHierarchyFilter (ItemGroup, ItemGroup, name, 'By name');

CONSTRAINT DROPPED (ItemGroup g IS ItemGroup) AND PREV (parent (ItemGroup child) = g)
         MESSAGE 'It is forbidden to delete groups that are referenced by other groups';

idParent (ItemGroup itemGroup) = overId (parent (itemGroup));

parent (ItemGroup itemGroup) + = parent (itemGroup);

in 'Mark.' = DATA LOCAL BOOLEAN (ItemGroup);

moveItemGroup 'Move selected groups to current' (itemGroup) {

     FOR in (ItemGroup i) DO {
         IF i! = ItemGroup THEN {
             parent (i) <- itemGroup;
             in (i) <- NULL;
         } ELSE {
             MESSAGE 'The selected product group cannot be the same as the merged one';
         }
     }
}

// ------------------ Forms --------------------- //

FORM itemGroup 'Product group'
     OBJECTS g = ItemGroup PANEL
     PROPERTIES (g) name, order, id SHOWIF showIDs (), nameParent
     EDIT ItemGroup OBJECT g
;

FORM itemGroups 'Product groups'
     PROPERTIES filterNameItemGroup ()

     TREE treeGroups g = ItemGroup PARENT parent (g)
     PROPERTIES in (g), moveItemGroup (g) TOOLBAR
     PROPERTIES READONLYIF isReadonly () order (g), id (g) SHOWIF showIDs (), name (g), canonicalName (g)
     PROPERTIES (g) NEWSESSION NEW, EDIT, deleteg = DELETE
     FILTERS inIFilterName (g) OR NOT filterNameItemGroup ()
     ORDERS order (g), canonicalName (g)
;

@extendFormEditable (itemGroups);

FORM dialogItemGroups 'Product groups'
     TREE treeGroups tg = ItemGroup PARENT parent (tg)
     PROPERTIES READONLY order (tg), id (tg) SHOWIF showIDs (), name (tg)
     ORDERS order (tg), name (tg)

     OBJECTS g = ItemGroup
     PROPERTIES (g) NEWSESSION order READONLY, id SHOWIF showIDs () READONLY, name READONLY, canonicalName READONLY, DELETE
     PROPERTIES (g) NEWSESSION NEW, EDIT
     ORDERS order (g), canonicalName (g)

     FILTERS isParent (g, tg)

     FILTERGROUP filters
         FILTER 'All leaves' isParentLeaf (g, tg) 'F10' DEFAULT
         FILTER 'All descendants' isParent (g, tg) 'F9'
         FILTER 'Only immediate children' parent (g) == tg 'F8'

     LIST ItemGroup OBJECT g
;

FORM dialogTreeItemGroups 'Product groups'
     TREE treeGroups tg = ItemGroup PARENT parent (tg)
     PROPERTIES READONLY order (tg), id (tg) SHOWIF showIDs (), name (tg)
     ORDERS order (tg), name (tg)
;

DESIGN dialogTreeItemGroups {
    size = (800, 600);
}

DESIGN dialogItemGroups {
    BOX {
        size = (1280, 1024);
        NEW rootContainer BEFORE TOOLBARBOX {
            fill = 1;
            type = SPLITH;
            MOVE BOX(TREE treeGroups);
            MOVE BOX(g) {
                fill = 2;
                GRID(g) { defaultComponent = TRUE; }
            }
        }
    }
}

NAVIGATOR {
    skuNavigator {
        NEW itemGroups BEFORE UOMs;
    }
}
// ----------------------------------- Products ------------ ----------------------- //

CLASS Item 'Product': Sku;
TABLE item (Item) FULL;
TABLE sessionItem (Session, Item);

TABLE itemDate (Item, DATE);
TABLE itemCountry (Item, Country);
TABLE sessionItemCountry (Session, Item, Country);
TABLE itemCountryDate (Item, Country, DATE);

DESIGN options {
     pane {
         NEW items {
             caption = 'Products';
         }
     }
};

id 'Code' = DATA STRING [100] (Item) IN id INDEXED CHARWIDTH 10;

TABLE itemId (STRING [100]);
item (id) = GROUP AGGR (Item item) BY id (item) MATERIALIZED TABLE itemId; // need MATERIALIZED so that it does not allow the same codes, but throws UPDATE_CONFLICT

@defineOption (replaceSpacesInItemId, 'Replace spaces in product code', items);
WHEN LOCAL CHANGED (id (Item i)) AND replaceSpacesInItemId () INLINE DO id (i) <- replace (id (i), '', '');

@defineNumeratedID (Item, 'Products');

id (Item sku) + = id (sku);

CONSTRAINT active (Sku sku) AND sku IS Item AND NOT idBarcode (sku) AND setIdBarcodeSku ()
    MESSAGE 'The item must have a barcode';

// Link with a group of products
itemGroup 'Item Group' = DATA ItemGroup (Item) AUTOSET INDEXED;
skuGroup (Item item) + = itemGroup (item);
countItem 'Number of products' (g) = GROUP SUM 1 BY itemGroup (Item i);

nameItemGroup 'Product group' (Item item) = name (itemGroup (item)) IN id;
canonicalNameItemGroup 'Item group' (Item item) = canonicalName (itemGroup (item)) IN base;
idItemGroup 'Product group code' (Item item) = id (itemGroup (item));

TABLE itemGroupItem (ItemGroup, Item);

isParent (ItemGroup itemGroup, Item item) = isParent (itemGroup (item), itemGroup) MATERIALIZED;

checkIsLeafItemGroup 'The product must be linked to the bottom node of the main classifier' = DATA BOOLEAN () COMPLEX;
noEventsInTransactionItem 'Disable event when merging products' = DATA BOOLEAN ();

EXTEND FORM options
    PROPERTIES checkIsLeafItemGroup (), noEventsInTransactionItem ()
;
DESIGN options {
    items {
        MOVE PROPERTY (checkIsLeafItemGroup ());
        MOVE PROPERTY (noEventsInTransactionItem ());
    }
}

CONSTRAINT CHANGED (itemGroup (Item i)) AND parent (itemGroup (i)) AND NOT isLeaf (itemGroup (i)) AND checkIsLeafItemGroup ()
    CHECKED BY itemGroup [Item]
    MESSAGE 'It is forbidden to bind goods to intermediate nodes of the main classifier';

// ------------------ Additional groups --------------- //
TABLE customGroupTypeItem (CustomGroupType, Item);
TABLE sessionCustomGroupTypeItem (Session, CustomGroupType, Item);
customGroup = DATA CustomGroup (CustomGroupType, Item);
customGroup (CustomGroupType type, Item item) + = customGroup (type, item);

nameCustomGroup 'Name' (CustomGroupType type, Item item) = name (customGroup (type, item));
canonicalNameCustomGroup 'Canonical Name' (CustomGroupType type, Item item) = canonicalName (customGroup (type, item));
idCustomGroup 'Code' (CustomGroupType type, Item item) = id (customGroup (type, item));

CONSTRAINT customGroupType (customGroup (CustomGroupType type, Item item))! = Type
           CHECKED BY customGroup [CustomGroupType, Item]
           MESSAGE 'The selected SKU classifier is of the wrong type';
	   
// Attributes
dataImage 'Image' = DATA IMAGEFILE (Item);
loadImage 'Load image' (Item item) {INPUT = dataImage (item) CHANGE; }
overImage '' = ABSTRACT VALUE IMAGEFILE (Item);

image (Item item) = OVERRIDE dataImage (item), overImage (item);
openImage 'Open image' (Item item) {open (image (item)); }
hasImage (Item item) = TRUE IF image (item) MATERIALIZED;

nullImage 'Reset' (Item item) {
    image (item) <- NULL;
}

image 'Image' (Batch batch) = image (sku (batch));

// -------------------------------- Markups for settlement types of prices ----------- --------------------- //

currentBasePrice 'Base Price' (CalcPriceListType type, Sku sku, Stock stock) = PREV (priceA [PriceListType, Sku, Stock, DATETIME] (basePriceListType (type), sku, stock, currentDateTime ()));
currentCalcPrice 'Estimated price' (PriceListType type, Sku sku, Stock stock) = PREV (priceA (type, sku, stock, currentDateTime ()));

// ------------------------------------ Forms ----------- --------------- //
backgroundCurrentCalcPrice = ABSTRACT CASE COLOR (CalcPriceListType, Sku, Stock);

FORM item 'Product'

    OBJECTS i = Item PANEL

    PROPERTIES (i) canonicalNameItemGroup, idBarcode ON CHANGE changeBarcode (i) EVENTID 'SCANNER',
                  dataImage, loadImage, nullImage, id SHOWIF showIDs ()

    OBJECTS b = Barcode
    PROPERTIES (b) id, date, caption, shortNameUOM,
                        amount, active, primary ON CHANGE changePrimary (b, i)
    PROPERTIES (i) generateBarcode DRAW b
    PROPERTIES (b) NEW, deleteb = DELETE GRID
    FILTERS sku (b) == i

    OBJECTS cgt = CustomGroupType
    PROPERTIES name (cgt) READONLY, canonicalNameCustomGroup (cgt, i)

    OBJECTS dtr = DATE PANEL
    PROPERTIES (dtr) VALUE BACKGROUND dateDiffersCurrent (dtr)

    OBJECTS c = Country
    PROPERTIES (c) READONLY name

    OBJECTS st2 = Stock PANEL
    PROPERTIES (st2) SELECTOR name
    FILTERS isCompany (st2)
    
    OBJECTS ct = CalcPriceListType
    PROPERTIES (ct) READONLY name, includeVAT [PriceListType], nameCurrency, nameRoundCondition,
                            nameBasePriceListType
    PROPERTIES (ct, i, st2) READONLY currentBasePrice
    PROPERTIES (ct, i) markup
    PROPERTIES (ct, i, st2) READONLY currentCalcPrice BACKGROUND backgroundCurrentCalcPrice (ct, i, st2)

    EDIT Item OBJECT i
;

DESIGN item {
    BOX {
        NEW itemHeader BEFORE TOOLBARBOX {
            alignment = STRETCH;
            type = COLUMNS;
            columns = 2;
            MOVE PROPERTY (canonicalNameItemGroup (i)) {
                caption = 'Full name of the group';
            }
            MOVE PROPERTY (idBarcode (i));
            MOVE PROPERTY (id (i));
        }
        NEW itemDetail BEFORE TOOLBARBOX {
            type = TABBED;
            fill = 1;
            NEW itemPrimary {
                type = SCROLL;
                caption = 'Basic data';
                fill = 1;
                NEW itemPrimaryPane {
    
                    NEW itemPrimaryRow1 {
                        alignment = STRETCH;
                        type = CONTAINERH;
                        NEW itemPrimaryColumn1 {
                            flex = 2;
                        }
                        NEW itemPrimaryColumn2 {
                            flex = 1;
                        }
                    }
                }
            }
            MOVE BOX (b) {caption = 'Barcodes'; }
            NEW itemGroup {
                type = CONTAINERV;
                caption = 'Classifiers';
                MOVE BOX (cgt);
            }
            NEW regionalPrm {
                type = CONTAINERV;
                caption = 'Regional Options';
                MOVE BOX (dtr);
                MOVE BOX (c);
            }
            NEW calcPriceListTypePrm {
                type = CONTAINERV;
                caption = 'Prices';
                type = CONTAINERV;
                MOVE BOX (st2);
                MOVE BOX (ct);
            }
            NEW itemImage {
                type = CONTAINERV;
                caption = 'Image';
                MOVE PROPERTY (dataImage (i)) {
                    caption = '';
                    fill = 1;
                }
                MOVE PROPERTY (loadImage (i));
                MOVE PROPERTY (nullImage (i));
            }
        }
    }
}

seekBarcode 'Barcode' = DATA LOCAL STRING [15] ();
seekSkuBarcode () {
    INPUT s = STRING [15] DO {
        seek (skuBarcode (s, currentDate ()));
        IF NOT skuBarcode (s, currentDate ()) THEN
            MESSAGE 'Barcode not found';
    }
}


disallowEditing 'Disallow Editing' = ABSTRACT BOOLEAN (Item);
enableEditing = Item s IS Item AND NOT disallowEditing (s);
disallowEditing [Sku] (Item sku) + = disallowEditing (sku);

edit (Item item) + {
    IF NOT disallowEditing (item) THEN {
        DIALOG EDIT Item = item DOCKED;
    } ELSE {
        MESSAGE 'It is forbidden to edit the product after processing.';
    }
};
addItem () {
    NEWSESSION {
        NEW i = Item AUTOSET
            REQUEST
                edit (i);
            DO
                seek (i);
    }
}
addSku () + {addItem (); }

background = ABSTRACT CASE COLOR (Item);

FORM items 'Products'

    OBJECTS gt = GroupType PANEL
    PROPERTIES (gt) SELECTOR name

    TREE groupTree g = Group PARENT parent (g)
    PROPERTIES READONLY order (g), id (g), name (g)
    FILTERS groupType (g) == gt, g IS Group AND NOT (g IS SkuGroup AND NOT g IS ItemGroup)
    ORDERS order (g), name (g)
    FILTERGROUP inactive1 FILTER 'Active' active (g) 'F5' DEFAULT
    
    OBJECTS i = Item
    PROPERTIES (i) READONLYIF isReadonly () idBarcode ON CHANGE changeBarcode (i) BACKGROUND background (i), image PANEL SHOWIF hasImage (i), id SHOWIF showIDs () BACKGROUND background (i)
    PROPERTIES (i) NEWSESSION NEW, edit = EDIT SHOWIF enableEditing (i), deletei = DELETE
    PROPERTIES seekBarcode () ON CHANGE seekSkuBarcode () EVENTID 'SCANNER'
    
    LIST Item OBJECT i
;

seekSkuGroupType () {SEEK items.gt = SystemGroupType.skuGroupType; }
EXTEND FORM items
    EVENTS
        ON INIT seekSkuGroupType ()
;

DESIGN items {
    NEW root {
        type = SPLITH;
        fill = 1;
        NEW filters {
            fill = 1;
            MOVE BOX (gt);
            NEW itemImage {
                fill = 1;
                type = SPLITV;
                MOVE BOX (TREE groupTree) {caption = 'Groups';}
                MOVE PROPERTY (image (i)) {
                    fill = 1;
                    caption = '';
                }
            }
        }
        NEW pane {
            fill = 4;
            type = CONTAINERV;
            MOVE BOX (i) {
                fill = 5;
                GRID (i) {
                    defaultComponent = TRUE;
                }
            }
            NEW tab {
                type = TABBED;
                fill = 1;
                NEW actions {
                    caption = 'Actions';
                    NEW actionsRow1 {
                        type = CONTAINERH;
                        NEW seek {
                            caption = 'Search';
                            type = CONTAINERH;
                            alignment = STRETCH;
                            MOVE PROPERTY (seekBarcode ()) {
                                changeKey = 'F4';
                            }
                        }
                    }
                    NEW actionsRow2 {
                        type = CONTAINERH;
                    }
                    NEW actionsRow3 {
                        type = CONTAINERH;
                        NEW actionsImport {
                            caption = 'Import';
                            type = CONTAINERH;
                            alignment = STRETCH;
                        }
                    
                    }
                }
            }
        }
    }

    MOVE TOOLBARBOX;
}

NAVIGATOR {
    skuNavigator {
        NEW items BEFORE itemGroups;
    }
}

@extendFormEditable (items);

// ----------------------------------- Product attributes ----------- ------------------------------- //

CLASS ABSTRACT ItemAttribute 'Item Attribute';
TABLE itemAttribute (ItemAttribute);
TABLE itemItemAttribute (Item, ItemAttribute);

// Display
META defineItemAttribute (attribute, caption, group)
    userShow ### attribute caption (itemGroup) = DATA BOOLEAN (ItemGroup) IN group;

    quantityChildWith ### attribute (ItemGroup itemGroup) = GROUP SUM 1 IF userShow ### attribute (ItemGroup childItemGroup) AND isParent (childItemGroup, itemGroup) MATERIALIZED;
    quantityParentWith ### attribute (ItemGroup itemGroup) = GROUP SUM 1 IF userShow ### attribute (ItemGroup parentItemGroup) AND isParent (itemGroup, parentItemGroup) MATERIALIZED;

    show ### attribute caption (ItemGroup itemGroup) = TRUE IF (quantityChildWith ### attribute (itemGroup) (+) quantityParentWith ### attribute (itemGroup))> 0 MATERIALIZED;
    showAny ### attribute caption (ItemGroup itemGroup) = show ### attribute (itemGroup) OR NOT itemGroup IS ItemGroup;

    show ### attribute caption (Item item) = TRUE IF quantityParentWith ### attribute (itemGroup (item));

    backgroundShow ### attribute (ItemGroup itemGroup) =
        IF userShow ### attribute (itemGroup) THEN
            RGB (0,0,0) IF itemGroup IS ItemGroup
        ELSE
            RGB (203,203,206) IF quantityChildWith ### attribute (itemGroup)! = DescendantNumber (itemGroup)
                             AND NOT quantityParentWith ### attribute (itemGroup);

    setNullShow ### attribute 'Remove flag for all descendants' (ItemGroup itemGroup) {
        FOR isParent (ItemGroup childGroup, itemGroup) DO {
            userShow ### attribute (childGroup) <- NULL;
        }
    } ASON CONTEXTMENU userShow ### attribute [ItemGroup] CONFIRM;
END

// Announcement
value = ABSTRACT ISTRING [255] (Item, ItemAttribute) MATERIALIZED;

META defineItemAttribute (attribute, formProperty, caption, group)
    @defineItemAttribute (attribute, caption, group);

    EXTEND FORM itemGroup PROPERTIES (g) userShow ### attribute;
    EXTEND FORM itemOptions PROPERTIES (g) READONLYIF isReadonly () show ### attribute BACKGROUND backgroundShow ### attribute (g);
    
    background ### attribute = ABSTRACT COLOR (Item);
    EXTEND FORM item PROPERTIES (i) formProperty ### attribute SHOWIF show ### attribute (i) BACKGROUND background ### attribute (i);
    EXTEND FORM items PROPERTIES (i) READONLYIF isReadonly () BEFORE deletei formProperty ### attribute SHOWIF showAny ### attribute (g);
END


// Primitive type
META definePrimitiveItemAttribute (attribute, type, caption, group)
    attribute caption = DATA type (Item) IN group;
    @defineItemAttribute (attribute,, caption, group);
END

META implementItemAttribute (property, caption, itemType, attributeClass)
    EXTEND CLASS itemType ## ItemAttribute {attributeClass caption}
    value [Item, itemType ## ItemAttribute] (Item i, itemType ## ItemAttribute a) + = WHEN a == itemType ## ItemAttribute. ## attributeClass AND i IS Item THEN property (i);
END

// Artiboot setting form
FORM itemOptions 'Attribute Setting'
    OBJECTS ia = ItemAttribute
    PROPERTIES staticIA = staticCaption (ia)

    TREE groups g = ItemGroup PARENT parent (g)
    PROPERTIES (g) READONLY order, id SHOWIF showIDs (), name
    PROPERTIES (g) NEWSESSION EDIT
    ORDERS order (g), name (g)
    
    TREE treeGroups tg = ItemGroup PARENT parent (tg)
    PROPERTIES (tg) READONLY order, id SHOWIF showIDs (), name
    ORDERS order (tg), name (tg)
    
    OBJECTS ia1 = ItemAttribute
    PROPERTIES staticIA1 = staticCaption (ia1)
    FILTERGROUP filterA1
        FILTER 'All' staticCaption (ia1)
;

DESIGN itemOptions {
    NEW itemTab {
        fill = 1;
        type = TABBED;
        MOVE BOX (ia) {caption = 'General';};
        NEW show {
            caption = 'Caption';
            fill = 1;
            MOVE BOX (TREE groups);
        }
        NEW items1 {
            fill = 1;
            caption = 'For groups';
            type = SPLITH;
            MOVE BOX (TREE treeGroups);
            MOVE BOX (ia1);
        }
    }
    MOVE TOOLBARBOX;
}

@extendFormEditable (itemOptions);

NAVIGATOR {
    skuNavigator {
        NEW itemOptions;
    }
}

META defineItemAttributeBatch (attribute, formProperty, caption, skuClass)
    show ### attribute caption (Batch batch) = show ### attribute (sku (batch));
    attribute caption (Batch batch) = attribute [Item] (sku (batch));

    EXTEND FORM batches PROPERTIES (bt) READONLY formProperty SHOWIF showAny ### attribute (sk);
END

META defineItemAttributeBatchClass (attribute, caption, skuClass)
    @defineItemAttributeBatch (attribute, attribute, caption, skuClass);
END

META defineItemAttributeBatch (attribute, formProperty, caption)
    @defineItemAttributeBatch (attribute, formProperty, caption, item);
END
META defineItemAttributeBatch (attribute, caption)
    @defineItemAttributeBatch (attribute, attribute, caption);
END

META defineObjectItemAttributeBatch (attribute, identity, caption)
    @defineObjectItemAttributeBatch (attribute, identity, caption, item);
END

META defineObjectItemAttributeBatch (attribute, identity, caption, skuClass)
    identity caption (Batch batch) = identity (sku (batch));
    @defineItemAttributeBatch (attribute, identity, caption, skuClass);
END

FORM attributesItem 'Product attributes'
;

DESIGN attributesItem {
    NEW tabContainer {
        fill = 1;
        type = TABBED;
    }
    MOVE TOOLBARBOX;
}

META defineUniteAttributeItem (object, nameProp, caption1, caption2, object2)
    in 'Mark.' = DATA LOCAL NESTED BOOLEAN (### object);
    allowReplace ### object = DATA LOCAL BOOLEAN ();
    
    FORM confirmReplace ### object 'Mergeable' ## caption2
        OBJECTS object = ### object PANEL
    
        OBJECTS o = ### object
        PROPERTIES (o) READONLY nameProp
        FILTERS o == object
    
        OBJECTS o2 = ### object
        PROPERTIES (o2) in
        PROPERTIES (o2) READONLY nameProp
        FILTERS in (o2)
    ;
    
    DESIGN confirmReplace ### object {
        REMOVE BOX (object);
        NEW splitContainer {
            type = SPLITV;
            fill = 1;
            MOVE BOX (o) {
                caption = 'Main' ## caption1;
            }
            MOVE BOX (o2) {
                caption = 'Removable' ## caption1;
            }
        }
        MOVE TOOLBARBOX;
    }
    
    overReplace (oTo, oFrom) ABSTRACT LIST (### object, ### object);
    replace 'Concatenate' (### object object) {
        DIALOG confirmReplace ### object OBJECTS o = object DO {
            allowReplace ### object () <- TRUE;
            FOR in (### object o) AND allowReplace ### object () DO {
                IF o! = Object THEN {
                    object (### object2 object2) <- object WHERE object (object2) == o;
                    overReplace (object, o);
                    in (o) <- NULL;
                    DELETE o;
                } ELSE {
                    MESSAGE 'Highlighted' ## caption1 ## 'cannot match the merged';
                }
            }
            apply ();
        }
    };
    
    EXTEND FORM attributesItem
        OBJECTS object = ### object
        PROPERTIES in (object)
        PROPERTIES READONLY nameProp (object)
        PROPERTIES (object) NEWSESSION NEW, EDIT, delete ### object = DELETE
        ORDERS nameProp (object)
        PROPERTIES replace (object) TOOLBAR
        
        OBJECTS object ## Item = Item
        PROPERTIES (object ## Item) READONLY idBarcode, nameProp, id [Sku], idSkuGroup
        PROPERTIES (object ## Item) nameProp ### object, EDIT NEWSESSION
        FILTERS object (object ## Item) == object
    ;
    
    DESIGN attributesItem {
        tabContainer {
            NEW object ## Tab {
                type = SPLITV;
                caption = '' ### caption2;
                MOVE BOX (object) {fill = 3; };
                NEW object ## TabBottomContainer {
                    type = TABBED;
                    fill = 1;
                    MOVE BOX (object ## Item);
                }
            }
        }
    }

END

META defineUniteFilterAttributeItem (object, nameProp, caption1, caption2, object2)
    @defineUniteAttributeItem (object, nameProp, caption1, caption2, object2);
    overReplace (### object oTo, ### object oFrom) + {
        dataIn (oTo, ### object2 ## Group g) <- dataIn (oFrom, g) WHERE dataIn (oFrom, g);
    }
END

META defineUniteAttributeItemWithoutExtendForm (object, nameProp, caption1, caption2, object2)
    in 'Mark.' = DATA LOCAL NESTED BOOLEAN (### object);
    
    FORM confirmReplace ### object 'Mergeable' ## caption2
        OBJECTS object = ### object PANEL
    
        OBJECTS o = ### object
        PROPERTIES (o) READONLY name
        FILTERS o == object
    
        OBJECTS o2 = ### object
        PROPERTIES (o2) in
        PROPERTIES (o2) READONLY name
        FILTERS in (o2)
    ;
    
    DESIGN confirmReplace ### object {
        REMOVE BOX (object);
        NEW splitContainer {
            type = SPLITV;
            fill = 1;
            MOVE BOX (o) {
                caption = 'Main' ## caption1;
            }
            MOVE BOX (o2) {
                caption = 'Removable' ## caption1;
            }
        }
        MOVE TOOLBARBOX;
    }
    
    replace 'Concatenate' (### object object) {
        DIALOG confirmReplace ### object OBJECTS o = object DO {
            FOR in (### object o) DO {
                IF o! = Object THEN {
                    object (### object2 object2) <- object WHERE object (object2) == o;
                    in (o) <- NULL;
                    DELETE o;
                } ELSE {
                    MESSAGE 'Highlighted' ## caption1 ## 'cannot be the same as being merged';
                }
            }
            apply ();
        }
        in (### object o) <- NULL;
    } CONFIRM;
END

NAVIGATOR {
    skuNavigator {
        NEW attributesItem;
    }
}


// - For two objects: set the default value for the group (hierarchy)
META defineItemDefaultValue (property, caption, type, typeIdentity, object)
    data ## type caption = DATA type (### object, ItemGroup);
    data ### typeIdentity ## type caption (### object object, ItemGroup itemGroup) = name (data ## type (object, itemGroup)) IN defaultItemGroup;
    
    levelParent ## type (### object object, ItemGroup itemGroup) = GROUP MIN level (itemGroup, ItemGroup parent) IF data ## type (object, parent) MATERIALIZED;
    nearestParent ## type (### object object, ItemGroup itemGroup) = itemGroup (itemGroup, levelParent ## type (object, itemGroup));
    nearest ## type (### object object, ItemGroup itemGroup) = data ## type (object, nearestParent ## type (object, itemGroup));
    
    property (### object object, ItemGroup itemGroup) =
        OVERRIDE data ## type (object, itemGroup),
                 ## type (object, itemGroup) MATERIALIZED;

    prev ### property (### object object, ItemGroup itemGroup) =
        OVERRIDE data ## type (object, itemGroup),
                 PREV (nearest ## type (object, itemGroup));
    
    typeIdentity caption (### object object, ItemGroup itemGroup) = name (property (object, itemGroup)) IN defaultItemGroup;
    prev ### typeIdentity caption (### object object, ItemGroup itemGroup) = name (prev ### property (object, itemGroup)) IN defaultItemGroup;
END

META defineItemDefaultValueCustom(property, caption, type, object)
    data###property caption = DATA type (###object, ItemGroup);
    
    levelParent###property (###object object, ItemGroup itemGroup) = GROUP MIN level(itemGroup, ItemGroup parent) IF data###property(object, parent) MATERIALIZED;    
    nearestParent###property (###object object, ItemGroup itemGroup) = itemGroup(itemGroup, levelParent###property(object, itemGroup));
    nearest###property (###object object, ItemGroup itemGroup) = data###property(object, nearestParent###property (object, itemGroup));
    
    property caption (###object object, ItemGroup itemGroup) =
        OVERRIDE data###property(object, itemGroup), 
                 nearest###property (object, itemGroup) MATERIALIZED;
                 
    quantityChild###property (###object object, ItemGroup itemGroup) = GROUP SUM 1 IF 
        data###property(object, ItemGroup childItemGroup) AND isParent(childItemGroup, itemGroup) MATERIALIZED;
    quantityParent###property (###object object, ItemGroup itemGroup) = GROUP SUM 1 IF 
        data###property(object, ItemGroup parentItemGroup) AND isParent(itemGroup, parentItemGroup) MATERIALIZED;                 

    backgroundWith###property (###object object, ItemGroup itemGroup) =
        IF data###property(object, itemGroup) THEN
            RGB(127,199,255) //IF itemGroup IS ItemGroup
        ELSE
            RGB(203,203,206) IF quantityChild###property (object, itemGroup) != descendantNumber(itemGroup)
                             AND NOT quantityParent###property (object, itemGroup);
                 
                 
END 

// Restrictions on the choice of lookup values
META defineItemAttributeForm (attribute, formProperty, caption, group)
    @defineItemAttribute (attribute, caption, group);
    
    EXTEND FORM itemGroup PROPERTIES (g) userShow ### attribute;
    EXTEND FORM itemOptions PROPERTIES (g) READONLYIF isReadonly () showAny ### attribute BACKGROUND backgroundShow ### attribute (g);
    
    background ### attribute = ABSTRACT COLOR (Item);
END

deleteUnusedAttributes 'Delete unused attributes' ABSTRACT LIST ();
trimAttributes 'Remove leading and trailing spaces from attribute names' = DATA BOOLEAN ();
EXTEND FORM options PROPERTIES () deleteUnusedAttributes, trimAttributes;
DESIGN options {
    items {
        MOVE PROPERTY (deleteUnusedAttributes ());
        MOVE PROPERTY (trimAttributes ());
    }
};

META defineObjectItemAttribute (attribute, attributeClass, identity, caption, group)
    attribute = DATA attributeClass (Item);
    deleteUnusedAttributes () + {
        NEWSESSION {
            FOR (attributeClass o IS attributeClass) AND NOT [GROUP SUM 1 BY attribute (Item item)] (o) DO DELETE o;
            apply ();
        }
    };
    identity ### attribute caption (Item item) = identity (attribute (item)) IN group;

    CONSTRAINT DROPPED (attributeClass o IS attributeClass) AND [GROUP SUM 1 IF NOT attribute (Item io) BY PREV (attribute (io))] (o)
        MESSAGE 'It is forbidden to delete the attribute (' ## caption ## '), as there are links to it in the product catalog';

    @defineItemAttributeForm (attribute, identity, caption, group);
END

@addRoleApplicationSetting(autoSetGroupAttribute, 'Автоматически проставлять привязки атрибутов к группам', BOOLEAN);
 
META defineItemFilterValue (object, captionProp, o)
    TABLE object ## ItemGroup (### object, ItemGroup);
      
    dataIn 'On' = DATA BOOLEAN (### object, ItemGroup);
    
    levelParentIn (### object object, ItemGroup itemGroup) = GROUP MIN level (itemGroup, ItemGroup parent) IF dataIn (object, parent) MATERIALIZED;
    nearestParentIn (### object object, ItemGroup itemGroup) = itemGroup (itemGroup, levelParentIn (object, itemGroup));
    nearestIn (### object object, ItemGroup itemGroup) = dataIn (object, nearestParentIn (object, itemGroup));
    
    in 'On' (### object object, ItemGroup itemGroup) =
        OVERRIDE dataIn (object, itemGroup),
                 nearestIn (object, itemGroup) MATERIALIZED;
                 
    quantityChild (### object object, ItemGroup itemGroup) = GROUP SUM 1 IF
        dataIn (object, ItemGroup childItemGroup) AND isParent (childItemGroup, itemGroup) MATERIALIZED;
    quantityParent (### object object, ItemGroup itemGroup) = GROUP SUM 1 IF
        dataIn (object, ItemGroup parentItemGroup) AND isParent (itemGroup, parentItemGroup) MATERIALIZED;

    backgroundWith (### object object, ItemGroup itemGroup) =
        IF dataIn (object, itemGroup) THEN
            RGB (0,0,0) // IF itemGroup IS ItemGroup
        ELSE
            RGB (203,203,206) IF quantityChild (object, itemGroup)! = DescendantNumber (itemGroup)
                             AND NOT quantityParent (object, itemGroup);
 
    countRec 'Amount (rec.)' (### object object, ItemGroup parent) = GROUP SUM 1 IF
        in (object, ItemGroup child) AND isParent (child, parent) MATERIALIZED;
    countDataItemGroup 'Number of groups' (### object object) = GROUP SUM 1 IF
        dataIn (object, ItemGroup itemGroup) MATERIALIZED;

    WHEN autoSetGroupAttribute (mainRole [CustomUser] (currentUser ())) AND (CHANGED (object (Item item)) OR CHANGED (itemGroup (item))) AND countDataItemGroup (object (item)) AND NOT countRec (object (item), itemGroup (item)) DO {
        dataIn (### object o, ItemGroup g) <- TRUE WHERE o == object (item) AND g == itemGroup (item);
    }

    CONSTRAINT object (Item item) AND itemGroup (item) AND countDataItemGroup (object (item)) AND NOT countRec (object (item), itemGroup (item))
        CHECKED BY object [Item]
            MESSAGE captionProp ## 'must be available for the product group (product)';

    EXTEND FORM object
        TREE groupTree g = ItemGroup PARENT parent (g)
        PROPERTIES READONLY order (g), name (g)
        PROPERTIES in (o, g) BACKGROUND backgroundWith (o, g)
        
        ORDERS order (g), name (g)
        FILTERS active (g)
    ;
    DESIGN object {
        OBJECTS {
            MOVE BOX (TREE groupTree);
        }
    }
    
    FORM object ### session 'Add'
        OBJECTS gg = ItemGroup PANEL
           
        OBJECTS v = ISTRING [100] PANEL
        PROPERTIES (v) val = VALUE
    ;
    
    DESIGN object ### session {
        BOX {
            REMOVE BOX (gg);
            size = (600, 400);
            MOVE BOX (v) {
                caption = captionProp;
                PROPERTY (val) {
                    caption = 'Caption';
                    panelCaptionAbove = TRUE;
                    font = 'bold 24';
                }
            }
            MOVE TOOLBARBOX;
        }
    }
    FORM object ## s ### session captionProp
        OBJECTS gg = ItemGroup PANEL
    
        OBJECTS t = ### object
        PROPERTIES (t) name READONLY
        ORDERS name (t)
    ;
    DESIGN object ## s ### session {BOX {size = (600, 400); }}   
  
add ### object 'Add' (ItemGroup gg) {
        DIALOG object ### session OBJECTS gg = gg, v INPUT DO {
            LOCAL loc = ### object ();
            LOCAL localName = ISTRING [100] ();
            localName () <- IF trimAttributes () THEN trim (v) ELSE v;
            NEWSESSION NESTED (localName, loc) {
                IF object ## Name (localName ()) THEN {
                    dataIn (### object t, gg) <- TRUE WHERE t == object ## Name (localName ());
                } ELSE {
                    NEW p = ### object {
                        name (p) <- localName ();
                        dataIn (p, gg) <- TRUE;
                        loc () <- p;
                    }
                }
                APPLY NESTED LOCAL;
            }
            SEEK object ## s ### session.t = (IF object ## Name (localName ()) THEN object ## Name (localName ()) ELSE loc ());
        }
    } TOOLBAR IMAGE 'add.png' CHANGEKEY 'INSERT';
    
    EXTEND FORM object ## s ### session
        PROPERTIES NEWSESSION add ### object (gg) DRAW t, EDIT (t), deletet = DELETE (t)
    ;
    
    change ### object (Item i) {
        DIALOG object ## s ### session OBJECTS gg = itemGroup (i), t = object (i) CHANGE;
    }
    EXTEND FORM item PROPERTIES (i) name ### object SHOWIF show ### object (i) BACKGROUND background ### object (i) ON CHANGE change ### object (i);
    EXTEND FORM items PROPERTIES (i) READONLYIF isReadonly () BEFORE deletei name ### object SHOWIF showAny ### object (g) ON CHANGE change ### object (i);

END

// ---------------------------- Attribute highlighting ------------------ -------------- //

skipExtractAttribute = ABSTRACT BOOLEAN (Item);

// -------------- Symbolic --------------------- //
FORM extractStringAttributeItem 'Attribute highlighting'
    OBJECTS from = STRING [100] PANEL
    PROPERTIES (from) from = VALUE
    
    OBJECTS to = STRING [100] PANEL
    PROPERTIES (to) to = VALUE
;

possibleStringAttributeValue = DATA LOCAL BOOLEAN (STRING [100]);
changePossibleStringAttributeValue (STRING [100] v) {
    SEEK extractStringAttributeItem.to = v;
}
 
EXTEND FORM extractStringAttributeItem
    OBJECTS v = STRING [100] GRID
    PROPERTIES (v) value = VALUE ON CHANGE changePossibleStringAttributeValue (v)
    FILTERS possibleStringAttributeValue (v)
    ORDERS value
;

DESIGN extractStringAttributeItem {
    PROPERTY (from) {
        caption = 'The sequence of characters to extract';
        font = '32';
        panelCaptionAbove = TRUE;
    }
    PROPERTY (to) {
        caption = 'The sequence of characters to replace with';
        font = '32';
        panelCaptionAbove = TRUE;
    }
    BOX (v) {
        caption = 'Possible values';
        PROPERTY (value) {
            caption = 'Value';
        }
    }
}

assignStringToFrom(STRING[100] from)  { 
    SEEK extractStringAttributeItem.to = from; 
} 
EXTEND FORM extractStringAttributeItem
    EVENTS 
        ON CHANGE from assignStringToFrom(from);
;

META defineItemExtractObjectAttribute (object, objectIdentity, identityObject)
    extract ### object ## FromCaption 'Extract from caption' (Item i) {
        IF i IS Item THEN {
            possibleStringAttributeValue (STRING [100] s) <- TRUE IF [GROUP SUM 1 IF in (### object object, ItemGroup g) BY name (object), g] (s, itemGroup (i));
            DIALOG extractStringAttributeItem OBJECTS from INPUT, to INPUT DO {
                LOCAL object = ### object ();
                object () <- identityObject (trim (to));
                IF NOT object () THEN {
                    NEW a = ### object {
                        name (a) <- trim (to);
                        object () <- a;
                    }
                }
                LOCAL selected = BOOLEAN (Item);
                selected (Item item) <- isSubstring (caption (item), from) AND [FILTER items.i] (item) AND NOT skipExtractAttribute (item);
                dataIn (### object a, ItemGroup g) <- TRUE WHERE a == object () AND [GROUP SUM 1 IF selected (Item item) BY itemGroup (item)] (g);
                object (Item item) <- object () WHERE selected (item);
                // cut out double spaces, as well as unnecessary characters at the beginning and end
                caption (Item item) <- rtrim (
                                        ltrim (
                                            replace (
                                                replace (
                                                    replace (
                                                        replace (
                                                            replace (caption (item), from, ''),
                                                            '', ''),
                                                        '""', ''),
                                                    '""', ''),
                                                '', ''),
                                            ',.'),
                                        ',.') WHERE selected (item);
            }
        }
    } ASON CONTEXTMENU objectIdentity [Item];
END

META defineItemExtractPrimitiveAttribute (property, form)
    extract ### property ## FromCaption 'Extract from name' (Item i) {
        IF i IS Item THEN {
            possibleStringAttributeValue (STRING [100] s) <- NULL;
            DIALOG form OBJECTS from INPUT, to INPUT DO {
                LOCAL selected = BOOLEAN (Item);
                selected (Item item) <- isSubstring (caption (item), from) AND [FILTER items.i] (item) AND NOT skipExtractAttribute (item);
                property (Item item) <- trim (to) WHERE selected (item);
                // cut out double spaces, as well as unnecessary characters at the beginning and end
                caption (Item item) <- rtrim (
                                        ltrim (
                                            replace (
                                                replace (
                                                    replace (
                                                        replace (
                                                            replace (caption (item), from, ''),
                                                            '', ''),
                                                        '""', ''),
                                                    '""', ''),
                                                '', ''),
                                            ',.'),
                                        ',.') WHERE selected (item);
            }
        }
    } ASON CONTEXTMENU property [Item];
END

// -------------- Symbolic --------------------- //

META defineItemExtractStringAttribute (property)
    @defineItemExtractPrimitiveAttribute (property, extractStringAttributeItem);
END

// -------------- Numeric --------------------- //
FORM extractDoubleAttributeItem 'Attribute highlighting'
    OBJECTS from = STRING [100] PANEL
    PROPERTIES (from) from = VALUE
    
    OBJECTS to = NUMERIC [20,7] PANEL
    PROPERTIES (to) to = VALUE
;

DESIGN extractDoubleAttributeItem {
    PROPERTY (from) {
        caption = 'The sequence of characters to extract';
        font = '32';
        panelCaptionAbove = TRUE;
    }
    PROPERTY (to) {
        caption = 'The number to use';
        font = '32';
        panelCaptionAbove = TRUE;
    }
}

assignDoubleToFrom (STRING [100] from) {
    SEEK extractDoubleAttributeItem.to = toInteger (replace (from AS STRING [100], '%', ''));
}
EXTEND FORM extractDoubleAttributeItem
    EVENTS
        ON CHANGE from assignDoubleToFrom (from);
;

META defineItemExtractDoubleAttribute (property)
    @defineItemExtractPrimitiveAttribute (property, extractDoubleAttributeItem, chosenNumeric);
END

// ---------------------------- Concrete properties ------------------ -------------- //

GROUP itemBase 'Base properties': base;
GROUP itemOriginal 'Original properties': base;

// Inactive
inactive 'Inactive' = DATA BOOLEAN (ItemGroup);
active 'Active' (ItemGroup group) = group IS ItemGroup AND NOT inactive (group);
inactive (ItemGroup group) + = inactive (group);

EXTEND FORM itemGroup PROPERTIES (g) inactive;
EXTEND FORM itemGroups
    PROPERTIES (g) READONLYIF isReadonly () inactive BEFORE canonicalName (g)
    FILTERGROUP inactive FILTER 'Active' active (g) 'F10' DEFAULT
;
EXTEND FORM dialogItemGroups
    FILTERGROUP inactive FILTER 'Active' active (tg) 'F10' DEFAULT
    FILTERGROUP inactive1 FILTER 'Active' active (g) 'F10' DEFAULT;

// Group
@implementItemAttribute (nameItemGroup, 'Product Group', String, itemItemGroup);

// ------ Basic properties of the product ------ //

// Title
caption 'Title' = DATA ISTRING [255] (Item) CHARWIDTH 20 IN itemBase;
@defineItemAttribute (caption,, 'Title', itemBase);
WHEN LOCAL FORMS item, items SETCHANGED (caption (Item i)) AND trimAttributes () DO {
    caption (i) <- trim (caption (i));
}

@defineItemGroupDefaultValue (caption, 'Title', ISTRING [255]);

@defineItemAttributeBatch (caption, 'Title');
@implementItemAttribute (caption, 'Title', String, itemCaption);

extractStringCaption 'Replace in title' (Item i) {
    IF i IS Item THEN {
        possibleStringAttributeValue (STRING [100] s) <- NULL;
        DIALOG extractStringAttributeItem OBJECTS from INPUT, to INPUT DO {
            LOCAL selected = BOOLEAN (Item);
            selected (Item item) <- isSubstring (caption (item), from) AND [FILTER items.i] (item) AND NOT skipExtractAttribute (item);
            // cut out double spaces, as well as unnecessary characters at the beginning and end
            caption (Item item) <- rtrim (
                                    ltrim (
                                        replace (
                                            replace (
                                                replace (
                                                    replace (
                                                        replace (caption (item), from, to),
                                                        '', ''),
                                                    '""', ''),
                                                '""', ''),
                                            '', ''),
                                        ',.'),
                                    ',.') WHERE selected (item);
        }
    }
} ASON CONTEXTMENU caption [Item];

@defineStringItemAttribute (originalCaption, ISTRING [100], 'Title (original)', itemOriginal);
@defineItemAttributeBatch (originalCaption, 'Title (original)');

// Unit of measurement
@defineObjectItemAttribute (UOM, UOM, name, 'Unit', itemBase);
@defineObjectItemAttributeBatch (UOM, nameUOM, 'Unit of measure', sku);

shortNameUOM 'Unit of measure' (Item item) = shortName (UOM (item)) IN itemBase;
UOM (Item item) + = UOM (item);

@defineItemGroupDefaultObject (UOM, 'Unit', UOM, nameUOM);
@defineItemFilterValue (UOM, 'Unit', u);

// @ implementObjectShortItemAttribute (UOM, 'Unit of measure (abbreviated)');
@implementItemAttribute (shortNameUOM, 'Unit of measure (abbreviated)', String, itemShortUOM);

@defineUniteFilterAttributeItem (UOM, name, 'unit of measure', 'unit of measure', item);
EXTEND FORM attributesItem
    PROPERTIES (UOM) READONLY AFTER name (UOM) grossWeight, netWeight, split, factor, genitiveName,
                                                shortNameBase, shortName, id SHOWIF showIDs ()
;

// Brand
CLASS Brand 'Brand';
TABLE brand (Brand);

EXTEND CLASS Brand {
    none 'No brand'
}

@defineExternalizable (brand, STRING [100]);

name 'Name' = DATA ISTRING [50] (Brand);
brandName = GROUP NAGGR Brand brand BY name (brand);

emptyName 'Name' (Brand b) = OVERRIDE name (b), 'Not set';

site 'Site address' = DATA ISTRING [100] (Brand);

FORM brand 'Brand'
    OBJECTS t = Brand PANEL
    PROPERTIES (t) name, emptyName READONLY, site, id SHOWIF showIDs ()
    EDIT Brand OBJECT t
;

FORM brands 'Brands'
    OBJECTS t = Brand
    PROPERTIES (t) NEWSESSION name READONLY, emptyName READONLY, site READONLY, id READONLY SHOWIF showIDs (), deleteb = DELETE
    PROPERTIES (t) NEWSESSION NEW, EDIT
    ORDERS name (t)
    LIST Brand OBJECT t
;
DESIGN brands {BOX {size = (600, 400); }}

@defineObjectItemAttribute (brand, Brand, name, 'Brand', itemBase);

idBrand (Barcode barcode) = id (brand (sku (barcode)));
nameBrand (Barcode barcode) = name (brand (sku (barcode)));

@defineObjectItemAttributeBatch (brand, nameBrand, 'Brand');
@implementItemAttribute (nameBrand, 'Brand', String, itemBrand);

@defineItemFilterValue (brand, 'Brand', t);
@defineItemExtractObjectAttribute (brand, nameBrand, brandName);

@defineUniteFilterAttributeItem (brand, name, 'brand', 'brands', item);
EXTEND FORM attributesItem
    PROPERTIES (brand) AFTER name (brand) READONLY site, id SHOWIF showIDs ()
;

INDEX brand (Item i);

// A country
@defineObjectItemAttribute (country, Country, name, 'Country', itemBase);
@defineObjectItemAttributeBatch (country, nameCountry, 'Country', sku);
@implementItemAttribute (nameCountry, 'Country', String, itemCountry);

@defineItemFilterValue (country, 'Country', c);

@defineUniteFilterAttributeItem (country, name, 'country', 'countries', item);
EXTEND FORM attributesItem
    PROPERTIES (country) READONLY AFTER name (country) nameLanguage, nameCurrency, resident,
                                                            sidOrigin3, sidOrigin2, sid, nameOrigin
;

resident 'Domestic production' (Item item) = resident (country (item)) IN itemBase;
country (Item sku) + = country (sku);

INDEX country (Item i);

// Manufacturer
CLASS Manufacturer 'Product manufacturer';
TABLE manufacturer (Manufacturer);

@defineExternalizable (manufacturer, STRING [200]);

name 'Name' = DATA ISTRING [200] (Manufacturer) IN id CHARWIDTH 15;
manufacturerName = GROUP NAGGR Manufacturer m BY name (m);
address 'Manufacturer's address' = DATA STRING [255] (Manufacturer) CHARWIDTH 20;

originalName 'Name (original)' = DATA ISTRING [100] (Manufacturer) CHARWIDTH 15;
originalAddress 'Manufacturer's address (original)' = DATA STRING [255] (Manufacturer) CHARWIDTH 20;

country = DATA Country (Manufacturer);
nameCountry 'Country' = name (country (Manufacturer m)) CHARWIDTH 20;

FORM manufacturer 'Product manufacturer'
    OBJECTS m = Manufacturer PANEL
    PROPERTIES (m) name, address, id SHOWIF showIDs (), originalName, originalAddress,
                  nameCountry
    EDIT Manufacturer OBJECT m
;

DESIGN manufacturer {
    BOX {
        PROPERTY (name (m)) {
            charWidth = 50;
        }
    }
}

FORM manufacturerDialog 'Product manufacturers'
    OBJECTS m = Manufacturer
    PROPERTIES (m) NEWSESSION name READONLY, id READONLY SHOWIF showIDs (),
                  originalName READONLY, originalAddress READONLY, nameCountry READONLY, deleteManufacturer = DELETE
    PROPERTIES (m) NEWSESSION NEW, EDIT
    ORDERS name (m)
    LIST Manufacturer OBJECT m
;
DESIGN manufacturerDialog {BOX {size = (600, 400); }}

@defineObjectItemAttribute (manufacturer, Manufacturer, name, 'Manufacturer', itemBase);
@defineObjectItemAttributeBatch (manufacturer, nameManufacturer, 'Manufacturer');
@implementItemAttribute (nameManufacturer, 'Manufacturer', String, itemManufacturer);

@defineItemFilterValue (manufacturer, 'Manufacturer', m);

@defineUniteFilterAttributeItem (manufacturer, name, 'manufacturer', 'manufacturers', item);
EXTEND FORM attributesItem
    PROPERTIES READONLY AFTER name (manufacturer) id (manufacturer) SHOWIF showIDs (),
                        originalName (manufacturer), originalAddress (manufacturer), nameCountry (manufacturer)

;

addressManufacturer 'Manufacturer's address' (Item item) = address (manufacturer (item));

INDEX manufacturer (Item i);

//  Composition
@defineStringItemAttribute (composition, STRING [1000], 'Composition', itemBase);
@defineItemAttributeBatchClass (composition, 'Composition', sku);
composition (Item sku) + = composition (sku);
DESIGN items {
    PROPERTY (composition (i)) {charWidth = 40;}
}

@defineStringItemAttribute (originalComposition, STRING [255], 'Composition (original)', itemOriginal);

// Tara
skuType = DATA SkuType (Item) NONULL;
skuType (Item sku) + = skuType (sku);

skuType (Item item) <- SkuType.skuTypeItem WHEN SET (item IS Item);

nameSkuType 'SKU Type' (Item item) = staticCaption (skuType (item)) IN itemBase;
EXTEND FORM item PROPERTIES (i) nameSkuType;
EXTEND FORM items PROPERTIES (i) READONLYIF isReadonly () nameSkuType;

// Weight
@definePrimitiveItemAttribute (split, BOOLEAN, 'Fractional', itemBase);
split (Item sku) + = split (sku);

split (Item i) <- split (UOM (i)) WHEN CHANGED (UOM (i));

// Fix price
@definePrimitiveItemAttribute (fixedPrice, BOOLEAN, 'Fixed price item', itemBase);
fixedPrice (Item sku) + = fixedPrice (sku);

// Inactive
inactive 'Inactive' = DATA BOOLEAN (Item) IN itemBase;
prevInactive (Item i) = PREV (inactive (i));

active 'Active' (Item item) = item IS Item AND NOT inactive (item);
prevActive = Item i IS Item AND NOT prevInactive (i);

inactive (Item sku) + = inactive (sku);
EXTEND FORM item PROPERTIES (i) inactive;
EXTEND FORM items
    PROPERTIES (i) READONLYIF isReadonly () inactive
    FILTERGROUP inactive2 FILTER 'Active' prevActive (i) 'F10' DEFAULT
;

DESIGN item {
    itemPrimaryColumn1 {
        MOVE GROUP (itemBase, i) {
            alignment = STRETCH;
            columns = 2;
            PROPERTY (composition (i)) {
                charWidth = 20;
            }
        }
        MOVE GROUP (itemOriginal, i) {
            alignment = STRETCH;
            columns = 2;
        }
    }
}
DESIGN item {
    itemPrimaryColumn1 {
        NEW regionPrm AFTER GROUP (itemBase, i) {
            alignment = STRETCH;
            type = COLUMNS;
            columns = 2;
            caption = 'Regional Properties';
        }
    }
}

// ------ Product dimensions ------ //

GROUP itemSize 'Product dimensions': public;

// Net weight
@defineDoubleItemAttribute (netWeight, NUMERIC [11,5], 'Net weight, kg', itemSize);
@defineItemAttributeBatchClass (netWeight, 'Net weight, kg', sku);
@implementItemAttribute (netWeight, 'Net weight, kg', Double, itemNetWeight);
netWeight (Item sku) + = netWeight (sku);
netWeight (Item i) <- netWeight (UOM (i)) WHEN CHANGED (UOM (i)) AND netWeight (UOM (i));

// Gross weight
@defineDoubleItemAttribute (grossWeight, NUMERIC [11,5], 'Gross weight, kg', itemSize);
@defineItemAttributeBatchClass (grossWeight, 'Gross weight, kg', sku);
grossWeight (Item sku) + = grossWeight (sku);

WHEN LOCAL (CHANGED (netWeight (Item sku)) OR (CHANGED (UOM (sku) AND grossWeight (UOM (sku))))) AND NOT CHANGED (grossWeight (sku)) DO
    grossWeight (sku) <- OVERRIDE grossWeight (UOM (sku)), netWeight (sku);

// Quantity in the package
// todo: here most likely it will be necessary to refactor to more complex logic
// @ defineDoubleItemAttribute (packQuantity, NUMERIC [9,3], 'Quantity in package', itemSize);
// packQuantitySku (sku) + = packQuantityItem (sku);

DESIGN item {
    itemPrimaryColumn2 {
        MOVE GROUP (itemSize, i) {
            alignment = STRETCH;
            columns = 2;
        }
    }
}

loadDefaultItemAttributes 'Load standard product attributes' ABSTRACT LIST ();
@implementLoadDefaultData (loadDefaultItemAttributes);

// ---------------------------------------------- Formation of names -------------------------------------- //

TABLE itemAttributeItemGroup (ItemAttribute, ItemGroup);

@defineItemDefaultValueCustom (required, 'Required', BOOLEAN, itemAttribute);

quantityChildWithRequired (ItemAttribute a, ItemGroup parent) = GROUP SUM 1 IF dataRequired (a, ItemGroup child) AND isParent (child, parent);
quantityParentWithRequired (ItemAttribute a, ItemGroup child) = GROUP SUM 1 IF dataRequired (a, ItemGroup parent) AND isParent (child, parent);

backgroundRequired (ItemAttribute a, ItemGroup g) =
    IF dataRequired (a, g) THEN
        RGB (0,0,0)
    ELSE
        RGB (203,203,206) IF quantityChildWithRequired (a, g)! = DescendantNumber (g)
                         AND NOT quantityParentWithRequired (a, g);

EXTEND FORM itemOptions
    PROPERTIES (ia1, tg) required BACKGROUND backgroundRequired (ia1, tg);

constraintRequired (ItemAttribute a, Item i) = (DROPPED (value (i, a)) OR SET (i IS Item)) AND required (a, itemGroup (i)) AND NOT value (i, a);

CONSTRAINT constraintRequired (ItemAttribute a, Item i)
    MESSAGE
    (GROUP CONCAT ('The product must have an attribute' + staticCaption (ItemAttribute ia)) IF
                    (GROUP SUM 1 IF constraintRequired (ia, Item ii)), '\ n');

// Base name
@defineItemAttributeName (,, id);


saveImage 'Save Image' (Item item) {
    LOCAL fileName = STRING [255] ();
    fileName () <- nameAttribute (item);
    WRITE CLIENT DIALOG image (item) TO fileName ();
} ASON CONTEXTMENU image [Item];

backgroundNameAttribute = RGB (127,199,255) IF overName (Item i);
changeNameAttribute ABSTRACT (Item);

EXTEND FORM item PROPERTIES (i) nameAttribute BACKGROUND backgroundNameAttribute (i) ON CHANGE changeNameAttribute (i);
DESIGN item {itemHeader {MOVE PROPERTY (nameAttribute (i)); }}

name (Item item) + = nameAttribute (item);
loadDefaultItemAttributes () + {
    numberInName (StringItemAttribute a) <- 1 WHERE a == StringItemAttribute.itemCaption;
}

EXTEND FORM items
    PROPERTIES READONLY BACKGROUND background (i) AFTER idBarcode (i) nameAttribute (i) // generally need to use nameAttributeGroupGroupTypeItem (g, gt, i) for speed, but then selection without groups will not work
    PROPERTIES READONLYIF isReadonly () BACKGROUND background (i) AFTER nameAttribute (i) idItemGroup (i), canonicalNameGroup (gt, i)

    FILTERGROUP groupFilters
        FILTER 'With groups' isParent (g, i) 'F9' DEFAULT
        FILTER 'No groups' gt IS GroupType AND NOT group (gt, i) 'F8'

    ORDERS nameAttribute (i)
;

DESIGN items {
    PROPERTY (canonicalNameGroup (gt, i)) {
        caption = 'Full name of the group';
    }
}
// Checkout
@defineItemAttributeName (cashRegister, '(cash)', public);
dataTitleCashRegister 'Cashier name' = DATA STRING [100] (Barcode);
titleCashRegister 'Cash register name' = OVERRIDE dataTitleCashRegister (Barcode barcode), nameCashRegisterAttribute (sku (barcode)) CHARWIDTH 30;
loadDefaultItemAttributes () + {
    numberInNameCashRegister (StringItemAttribute a) <- 1 WHERE a == StringItemAttribute.itemCaption;
}
// Libra
@defineItemAttributeName (scales, '(scales)', public);
dataTitleScales 'Name for scale' = DATA STRING [100] (Barcode);
titleScales 'Name for scales' = OVERRIDE dataTitleScales (Barcode barcode), nameScalesAttribute (sku (barcode)) CHARWIDTH 30;
loadDefaultItemAttributes () + {
    numberInNameScales (StringItemAttribute a) <- 1 WHERE a == StringItemAttribute.itemCaption;
}

// Expiry dates
GROUP itemExpiry 'Expiry dates': public;

expiryDays 'Expiry date in days' = DATA INTEGER (Item) IN itemExpiry;
expiryDays (Item i) + = expiryDays (i);

expiryMonth 'Expiry date in months' = DATA INTEGER (Item) IN itemExpiry;
expiryMonth (Item i) + = expiryMonth (i);

hoursExpiryPack 'Expiry date in hours' = DATA INTEGER (Item) IN itemExpiry;

overChangeExpiryMonth ABSTRACT LIST (Item, INTEGER);
changeExpiryMonth (Item i) {
    INPUT int = INTEGER DO {
        expiryMonth (i) <- int;
        overChangeExpiryMonth (i, int);
    }
}

overChangeExpiryDays ABSTRACT LIST (Item, INTEGER);
changeExpiryDays (Item i) {
    INPUT int = INTEGER DO {
        expiryDays (i) <- int;
        overChangeExpiryDays (i, int);
    }
}

overChangeHoursExpiryPack ABSTRACT LIST (Item, INTEGER);
changeHoursExpiryPack (Item i) {
    INPUT int = INTEGER DO {
        hoursExpiryPack (i) <- int;
        overChangeHoursExpiryPack (i, int);
    }
}

expiry 'Expiry date' = DATA BOOLEAN (Item) IN itemExpiry;

@defineItemAttribute (expiry, 'Expiry Date', itemExpiry);

EXTEND FORM itemGroup PROPERTIES (g) userShowExpiry;
EXTEND FORM itemOptions PROPERTIES (g) READONLYIF isReadonly () showExpiry BACKGROUND backgroundShowExpiry (g);
EXTEND FORM item PROPERTIES (i) SHOWIF showExpiry (i) hoursExpiryPack ON CHANGE changeHoursExpiryPack (i), expiryDays ON CHANGE changeExpiryDays (i), expiryMonth ON CHANGE changeExpiryMonth (i);
EXTEND FORM items PROPERTIES (i) READONLYIF isReadonly () BEFORE deletei SHOWIF showExpiry (g) hoursExpiryPack, expiryDays, expiryMonth;
DESIGN item {
    itemPrimaryColumn2 {
        MOVE GROUP (itemExpiry, i) {
            alignment = STRETCH;
            PROPERTY (expiryDays (i)) {caption = 'In days'; }
            PROPERTY (hoursExpiryPack (i)) {caption = 'In hours'; }
            PROPERTY (expiryMonth (i)) {caption = 'In months'; }
            columns = 2;
        }
    }
}


// --------------------------------------- Генерация штрихкодов --------------------------------------------- //

META defineNumeratorItemGroup (prefix, caption, group)
    data###prefix##Numerator = DATA Numerator (ItemGroup);
    levelParent###prefix##Numerator(ItemGroup itemGroup)  = GROUP
                                                                  MIN level(itemGroup, ItemGroup parent) IF data###prefix##Numerator(parent) MATERIALIZED;
    nearestParent###prefix##Numerator (ItemGroup itemGroup) = itemGroup(itemGroup, levelParent###prefix##Numerator(itemGroup));
    nearest###prefix##Numerator (ItemGroup itemGroup) = data###prefix##Numerator(nearestParent###prefix##Numerator(itemGroup)) MATERIALIZED;

    prefix##Numerator (ItemGroup itemGroup) =
        OVERRIDE data###prefix##Numerator(itemGroup), nearest###prefix##Numerator(itemGroup) MATERIALIZED;
    name###prefix##Numerator caption (ItemGroup itemGroup) = name(prefix##Numerator(itemGroup)) CHARWIDTH 5 IN group;

    background###prefix##Numeratot (ItemGroup itemGroup) = IF data###prefix##Numerator(itemGroup) THEN
                                                                      RGB(190,190,190) IF itemGroup IS ItemGroup
                                                                  ELSE
                                                                      RGB(230,230,230) IF prefix##Numerator (itemGroup);

    EXTEND FORM itemGroup PROPERTIES(g)  AFTER nameParent(g) name###prefix##Numerator;
    EXTEND FORM itemGroups PROPERTIES(g) AFTER canonicalName(g) READONLYIF isReadonly() name###prefix##Numerator  BACKGROUND background###prefix##Numeratot(g);
END

@defineNumeratorItemGroup (piece, 'Barcode Numerator (for piece goods)', paramsItemGroup);
pieceNumerator (Item item) = pieceNumerator (itemGroup (item));

overNumerator = ABSTRACT CASE Numerator (Item);
barcodeNumerator (Item item) + = OVERRIDE overNumerator (item), pieceNumerator (item);

DESIGN itemGroup {
    BOX {
        NEW itemGroupHeader BEFORE TOOLBARBOX {
            alignment = STRETCH;
            NEW itemGroupHeader1 {
                caption = 'Product group';
                alignment = STRETCH;
                type = COLUMNS;
                columns = 3;
                MOVE PROPERTY (name (g));
                MOVE PROPERTY (order (g));
                MOVE PROPERTY (id (g));
                MOVE PROPERTY (nameParent (g));
                MOVE PROPERTY (inactive (g));
            }

// NEW itemGroupHeader2 {
// caption = 'Numerators';
// type = CONTAINERH;
// MOVE PROPERTY (namePieceNumerator (g));
//}
        }

        NEW pane BEFORE TOOLBARBOX {
            fill = 1;
            type = TABBED;
            NEW params {
                fill = 1;
                caption = 'Options';
                MOVE GROUP (paramsItemGroup, g);
            }
            NEW attributes {
                fill = 1;
                caption = 'Attributes';
                MOVE GROUP (itemBase, g) {
                    columns = 6;
                }
                MOVE GROUP (itemOriginal, g) {
                    columns = 6;
                }
                MOVE GROUP (itemSize, g) {
                    columns = 6;
                }
                NEW itemGroupDetail1 {
                    type = CONTAINERH;
                    MOVE GROUP (itemExpiry, g) {type = CONTAINERH;}
                }
            }
        }
    }
}

// ---------------------------------------- Copying an item ------ ----------------- //
overCopy ABSTRACT LIST (Item, Item);
overCopyEx ABSTRACT LIST (Item, Item);
overCopyItem ABSTRACT LIST (Barcode, Barcode, Sku);
toCopy = ABSTRACT CASE BOOLEAN (Barcode);

copyDataItem (Item item, Item i) {
    itemGroup (i) <- itemGroup (item);
    caption (i) <- caption (item);
    originalCaption (i) <- originalCaption (item);
    UOM (i) <- UOM (item);
    brand (i) <- brand (item);
    manufacturer (i) <- manufacturer (item);
    composition (i) <- composition (item);
    originalComposition (i) <- originalComposition (item);
    netWeight (i) <- netWeight (item);
    grossWeight (i) <- grossWeight (item);
    country (i) <- country (item);
    dataImage (i) <- dataImage (item);
    skuType (i) <- skuType (item);
    split (i) <- split (item);
    inactive (i) <- inactive (item);
    expiryDays (i) <- expiryDays (item);
    expiryMonth (i) <- expiryMonth (item);
    hoursExpiryPack (i) <- hoursExpiryPack (item);

    FOR sku (Barcode barcode) == item AND toCopy (barcode) DO {
        NEW b = Barcode {
            sku (b) <- i;
            dataDate (b) <- dataDate (barcode);
            dataUOM (b) <- dataUOM (barcode);
            dataAmount (b) <- dataAmount (barcode);
            dataTitleScales (b) <- dataTitleScales (barcode);
            dataTitleCashRegister (b) <- dataTitleCashRegister (barcode);
            
            overCopyItem (b, barcode, i);
        }
    }

    customGroup [CustomGroupType, Item] (CustomGroupType type, i) <- customGroup [CustomGroupType, Item] (type, item);

    overCopy (item, i);
    overCopyEx (item, i);
}

copy 'Copy' (Item item) {
    IF (item IS Item) THEN {
        NEWSESSION NESTED (addedSku []) {
            NEW i = Item {
                copyDataItem (item, i);
                DIALOG item OBJECTS i = i DOCKED NOCANCEL DO {
                    addedSku () <- i;
                }
            }
        }
    }
} CHANGEKEY 'F5' TOOLBAR;

copyItems 'Copy' (Item item) {
    copy (item);
    IF (addedSku ()) THEN {
        SEEK items.i = addedSku ();
    }
} CHANGEKEY 'F5' TOOLBAR;

EXTEND FORM items PROPERTIES (i) copyItems;
DESIGN items {PROPERTY (copyItems (i)) {focusable = FALSE; }}

copy (Item sku) + {copy (sku); }

createItemBarcode (STRING [15] barcode, DATE date) {
NEWSESSION {

LOCAL copy = BOOLEAN ();
copy () <- NULL;
IF skuAdded (currentUser ()) IS Item THEN {
ASK 'Create product based on the last one created?' DO
copy () <- TRUE;
}

IF copy () THEN {
NEW i = Item {
copyDataItem (skuAdded (currentUser ()), i);
NEW bc = Barcode {// barcode copying is now enabled only for barcode packaging
id (bc) <- barcode;
dataDate (bc) <- date;
sku (bc) <- i;
}
SHOW item OBJECTS i = i WAIT DOCKED;
}
} ELSE {
NEW bc = Barcode {
id (bc) <- barcode;
dataDate (bc) <- date;

NEW s = Item {
sku (bc) <- s;
SHOW item OBJECTS i = s, b = bc WAIT DOCKED;
}
}
}
}
}

createSkuBarcode (STRING [15] barcode, DATE date) + {createItemBarcode (barcode, date); }

in 'Mark.' = DATA LOCAL BOOLEAN (Item);

countInItem = GROUP SUM 1 IF in (Item item);

checkReplace ABSTRACT (Item);

FORM confirmReplaceItem 'Merging Products'
    OBJECTS item = Item PANEL

    OBJECTS i = Item
    PROPERTIES (i) READONLY idBarcode, nameAttribute
    FILTERS i == item

    OBJECTS i2 = Item
    PROPERTIES (i2) in
    PROPERTIES (i2) READONLY idBarcode, nameAttribute
    FILTERS in (i2)
;

DESIGN confirmReplaceItem {
    REMOVE BOX (item);
    NEW splitContainer {
        type = SPLITV;
        fill = 1;
        MOVE BOX (i) {
            caption = 'Main Product';
        }
        MOVE BOX (i2) {
            caption = 'Product to remove';
        }
    }
    MOVE TOOLBARBOX;
}

replaceDelNames 'Deleted Items' = DATA LOCAL NESTED STRING [500] ();

replace 'Combine' (Item item) {
    IF noEventsInTransactionItem () THEN setNoEventsInTransaction ();
    DIALOG confirmReplaceItem OBJECTS item = item DO {
        allowReplaceItem () <- TRUE;
        checkReplace (item);
        replaceDelNames () <- '';
        FOR in (Item i) AND allowReplaceItem () AND item IS Item DO {
            IF i! = Item THEN {
                replaceBefore (i, item);
                replace (i, item);
                overReplace (i, item);
                in (i) <- NULL;
                replaceDelNames () <- CONCAT '', replaceDelNames (), nameAttribute (i) + ',';
                DELETE i;
            } ELSE {
                MESSAGE 'The selected item cannot be the same as the merged item';
            }
        }
        replaceAfter (item);
        apply ();
    }
    in (Item i) <- NULL;
    IF noEventsInTransactionItem () THEN dropNoEventsInTransaction ();
} CONFIRM;

changeGroupItem 'Change group' () {
    DIALOG dialogItemGroups OBJECTS g INPUT DO
        FOR in (Item i) DO {
            itemGroup (i) <- g;
        }
}

EXTEND FORM items
    PROPERTIES (i) in BEFORE idBarcode (i), replace
;
DESIGN items {
    actionsRow1 {
        NEW replace {
            caption = 'Merging Products';
            alignment = STRETCH;
            MOVE PROPERTY (replace (i));
        }
    }
}

// -------------------- Automatic parameter date stamping ------------------ //

defaultItemDate 'Date for default locale' = DATA DATE ();
EXTEND FORM options PROPERTIES () defaultItemDate;
DESIGN options {
    items {
        MOVE PROPERTY (defaultItemDate ());
    }
}

seekItemDate () {
    IF defaultItemDate () THEN {
        SEEK item.dtr = defaultItemDate ();
    }
}
EXTEND FORM item
    EVENTS ON INIT seekItemDate ()
;

// ----------- Setting the default value ---------------- //
TABLE customGroupTypeItemGroup (CustomGroupType, ItemGroup);
@defineItemDefaultValue (customGroup, 'Additional group (default)', CustomGroup, nameCustomGroup, customGroupType);

assignCustomGroupItems 'Assign to all group items' (ItemGroup group) {
NEWSESSION {
FOR CustomGroupType t IS CustomGroupType DO {
            IF customGroup (t, group)
                THEN customGroup (t, Item i) <- customGroup (t, itemGroup (i)) WHERE isParent (group, i);
                ELSE {
                    ASK 'No group is specified for the classifier type' + name (t) + '. Clear the value of this classifier for all products in the group? ' DO {
                                        customGroup (t, Item i) <- customGroup (t, itemGroup (i)) WHERE isParent (group, i);
                                    }
                }
}
apply ();
}
} TOOLBAR CONFIRM;

assignCustomGroupItems 'Assign to all group items' (ItemGroup group, CustomGroupType t) {
NEWSESSION {
        customGroup (t, Item i) <- customGroup (t, itemGroup (i)) WHERE isParent (group, i);
apply ();
}
} CONFIRM;
EXTEND FORM itemGroup
    OBJECTS dc = CustomGroupType
    PROPERTIES (dc) READONLY name, id
    PROPERTIES (dc, g) prevNameCustomGroup
    PROPERTIES assignCustomGroupItems (g, dc) GRID, assignCustomGroupItems (g) DRAW dc
;
DESIGN itemGroup {

    pane {
        NEW default {
            fill = 1;
            caption = 'Default values';
            MOVE GROUP (defaultItemGroup, g) {
                caption = '';
                alignment = STRETCH;
                columns = 3;
                PROPERTY (prevCaption (g)) {charWidth = 20;}
            }
            NEW defaultPane {
                fill = 1;
                type = TABBED;
                MOVE BOX (dc) {caption = 'Additional classifier';}
            }
        }
    }
}

WHEN LOCAL CHANGED (itemGroup (Item i)) AND CustomGroupType dc IS CustomGroupType AND NOT customGroup (dc, i) DO
    customGroup (dc, i) <- customGroup (dc, itemGroup (i));
    
// form for viewing product information
FORM itemInfo 'Product Information'
    OBJECTS dates = (df = DATE, dt = DATE) PANEL
    PROPERTIES dFrom = VALUE (df), dTo = VALUE (dt)

    OBJECTS s = Sku PANEL
    PROPERTIES (s) READONLY id SHOWIF showIDs (), idBarcode, name, nameUOM, canonicalNameSkuGroup, nameCountry, nameBrand, resident, nameManufacturer, valueVAT
    
    OBJECTS st = Stock
    PROPERTIES (st) READONLY name
    PROPERTIES (s, st) READONLY valueVAT
    FILTERS isCompany (st),
            accessCompany (st)
    
    OBJECTS st1 = Stock PANEL
    PROPERTIES (st1) name SELECTOR
    FILTERS isCompany (st1),
            accessCompany (st1)
    
    OBJECTS b = Batch
    PROPERTIES (b) READONLY name, nameSupplier, shippedQuantity, currentBalance, cost, dateTime, seriesNumber
    PROPERTIES (b, st1) currentBalance
    ORDERS dateTime (b) DESC
    FILTERS sku (b) == s
;

setDates () {
    SEEK itemInfo.df = sum (currentDate (), -7);
}

EXTEND FORM itemInfo
    EVENTS ON INIT setDates ()
;

DESIGN itemInfo {
    BOX {
        size = (1024, 768);
        NEW topContainer {
            caption = 'Information';
            alignment = STRETCH;
            NEW firstLine {
                type = CONTAINERH;
                fill = 1;
                MOVE PROPERTY (name (s)) {alignment = STRETCH; }
                NEW secondFirstLine {
                    type = CONTAINERH;
                    MOVE PROPERTY (id (s));
                    MOVE PROPERTY (idBarcode (s));
                    MOVE PROPERTY (nameUOM (s));
                }
            }
            MOVE PROPERTY (canonicalNameSkuGroup (s)) {
                alignment = STRETCH;
                caption = 'Product group';
            }
            NEW secondLine {
                type = CONTAINERH;
                alignment = STRETCH;
                MOVE PROPERTY (nameCountry (s));
                MOVE PROPERTY (nameBrand (s));
                MOVE PROPERTY (nameManufacturer (s));
                MOVE PROPERTY (resident (s));
                MOVE PROPERTY (valueVAT (s));
            }
        }
        NEW stockFilter {
            caption = 'Filter';
            MOVE PROPERTY (name (st1)) {caption = 'Warehouse'; charWidth = 50; }
        }
        NEW bottomContainer {
            type = TABBED;
            fill = 1;
            NEW stocks {
                caption = 'By Warehouse';
                NEW dates {
                    caption = 'Spacing';
                    type = CONTAINERH;
                    MOVE PROPERTY (dFrom) {caption = 'Date since';}
                    MOVE PROPERTY (dTo) {caption = 'Date to';}
                }
                MOVE BOX (st);
            }
            NEW batches {
                caption = 'By Party';
                MOVE BOX (b);
            }
        }
    }
    MOVE TOOLBARBOX;
}

showInfoSku 'Show product information' (Item item) {NEWSESSION {SHOW itemInfo OBJECTS s = item AS Item; }} ASON CONTEXTMENU name [Item];
showInfoSkuA 'Show product information' (Item item) {NEWSESSION {SHOW itemInfo OBJECTS s = item AS Item; }} ASON CONTEXTMENU nameAttribute [Item];

META defineInfoSku (detail)
     showInfoSku 'Show product information' (### detail detail) {
         FOR s == sku (detail) DO
             SHOW itemInfo OBJECTS s = s; }
     ASON CONTEXTMENU nameSku [### detail];
END

// ------------------------------------------------ ------
EXTEND FORM options
     PROPERTIES () nameDefaultGroupType
;
DESIGN options {
     items {
         MOVE PROPERTY (nameDefaultGroupType ());
     }
}

// Price range

CLASS PriceSegment 'Price segment';
TABLE priceSegment (PriceSegment);

name 'Name' = DATA ISTRING [100] (PriceSegment) CHARWIDTH 10;
priceSegment = GROUP AGGR PriceSegment p BY name (p);
background 'Backlight' = DATA COLOR (PriceSegment);

order 'Order' = DATA INTEGER (PriceSegment);

FORM priceSegment 'Price Segments'
     OBJECTS t = PriceSegment PANEL
     PROPERTIES (t) name, order, background
     EDIT PriceSegment OBJECT t
;

FORM priceSegments 'Price segments'
     OBJECTS t = PriceSegment
     PROPERTIES (t) READONLY name, order, background
     PROPERTIES (t) NEWSESSION NEW, EDIT, DELETE
     ORDERS order (t), name (t)
     LIST PriceSegment OBJECT t
;
DESIGN priceSegments {BOX {size = (600, 400); }}

@defineObjectItemAttribute (priceSegment, PriceSegment, name, 'Price Segment', itemBase);

priceSegmentName = GROUP NAGGR PriceSegment p BY name (p);

@defineItemFilterValue (priceSegment, 'Price Segment', t);
@defineUniteFilterAttributeItem (priceSegment, name, 'price segment', 'price segments', item);

@definePrimitiveItemAttribute (banPurchase, BOOLEAN, 'Prohibit Purchase', itemBase);
banPurchase 'Ban Procurement' = DATA BOOLEAN (LegalEntity) IN filterEntity;
EXTEND FORM legalEntity
    PROPERTIES (l) banPurchase
;

// ----------------------- Transition to the new main classifier -------------------- ------- //

FORM copyToCustomGroupDialog 'Create a copy of the main classifier'
    OBJECTS i = STRING [100] PANEL, n = STRING [50] PANEL
    PROPERTIES id = VALUE (i), name = VALUE (n)
;
DESIGN copyToCustomGroupDialog {
    OBJECTS {
        MOVE PROPERTY (id) {caption = 'Code';}
        MOVE PROPERTY (name) {caption = 'Name';}
    }
}

overCopyToCustomGroup ABSTRACT LIST (ItemGroup, CustomGroup);

copyToCustomGroup 'Create a copy of the main classifier' () {
    NEWSESSION DIALOG copyToCustomGroupDialog OBJECTS i INPUT, n INPUT DO {
        NEW gt = CustomGroupType {
            id (gt) <- i;
            name (gt) <- n;
            
            FOR ItemGroup g IS ItemGroup ORDER level (g), g DO NEW ng = CustomGroup {
                customGroupType (ng) <- gt;
                id (ng) <- id (g);
                name (ng) <- name (g);
                parent (ng) <- customGroup (id (parent (g)), gt);
                
                overCopyToCustomGroup (g, ng);
            }
            FOR itemGroup (Item item) DO {
                customGroup (gt, item) <- customGroup (id (itemGroup (item)), gt);
            }
        }
        APPLY;
    }
}

new = DATA LOCAL BOOLEAN (ItemGroup);
itemGroup 'Match' = DATA LOCAL ItemGroup (CustomGroup);
nameItemGroup 'Match' (CustomGroup g) = name (itemGroup (g));

FORM replaceToItemGroupDialog 'Matching groups to transfer settings'
    OBJECTS t = CustomGroupType PANEL
    PROPERTIES (t) READONLY name
    
    TREE treeGroups g = CustomGroup PARENT parent (g)
    PROPERTIES (g) READONLY id, name, canonicalName
    PROPERTIES (g) nameItemGroup
    FILTERS customGroupType (g) == t
    ORDERS canonicalName (g)
;

overReplaceToItemGroup ABSTRACT LIST (CustomGroup, ItemGroup);

overOkReplaceToItemGroupDialog 'OK' (CustomGroupType t) {
    IF (GROUP SUM 1 IF customGroupType (CustomGroup g) == t AND NOT itemGroup (g)) THEN
        ASK 'Not all groups have been matched. Do you want to continue replacing? ' DO {
        } ELSE {
            RETURN;
        }
    printToLog ('' + currentDateTime () + 'Creating new ItemGroups');
    FOR customGroupType (CustomGroup g) == t AND NOT id (g) == 'All' ORDER level (g), g DO NEW ng = ItemGroup {
        id (ng) <- 'tst_' + id (g);
        name (ng) <- name (g);
        parent (ng) <- IF id (parent (g)) == 'All' THEN itemGroup ('All') ELSE itemGroup ('tst_' + id (parent (g)));
        order (ng) <- order (g);

        pieceNumerator (ng) <- pieceNumerator (itemGroup (g));
        userShowCaption (ng) <- userShowCaption (itemGroup (g));
        userShowUOM (ng) <- userShowUOM (itemGroup (g));
        userShowBrand (ng) <- userShowBrand (itemGroup (g));
        userShowCountry (ng) <- userShowCountry (itemGroup (g));
        userShowManufacturer (ng) <- userShowManufacturer (itemGroup (g));
        userShowComposition (ng) <- userShowComposition (itemGroup (g));
        userShowSplit (ng) <- userShowSplit (itemGroup (g));
        userShowFixedPrice (ng) <- userShowFixedPrice (itemGroup (g));
        userShowPriceSegment (ng) <- userShowPriceSegment (itemGroup (g));
        userShowBanPurchase (ng) <- userShowBanPurchase (itemGroup (g));
        userShowOriginalCaption (ng) <- userShowOriginalCaption (itemGroup (g));
        userShowOriginalComposition (ng) <- userShowOriginalComposition (itemGroup (g));
        userShowNetWeight (ng) <- userShowNetWeight (itemGroup (g));
        userShowGrossWeight (ng) <-userShowGrossWeight (itemGroup (g));
        userShowExpiry (ng) <- userShowExpiry (itemGroup (g));
        dataCaption (ng) <- prevCaption (itemGroup (g));
        dataUOM (ng) <- prevUOM (itemGroup (g));
        dataCustomGroup (CustomGroupType cgt, ng) <- prevCustomGroup (cgt, itemGroup (g));

        overReplaceToItemGroup (g, ng);

        new (ng) <- TRUE;
    }
    TRY {
        setNoCancelInTransaction ();
        APPLY NESTED LOCAL;
        IF canceled () THEN {
            printToLog ('' + currentDateTime () + 'ERROR' + applyMessage ());
        } ELSE {
            printToLog ('' + currentDateTime () + 'Changing itemGroup in Items');
            itemGroup (Item item) <- itemGroup ('tst_' + id (customGroup (t, item)));
            setNoCancelInTransaction ();
            APPLY NESTED LOCAL;
            IF canceled () THEN {
                printToLog ('' + currentDateTime () + 'ERROR' + applyMessage ());
            } ELSE {
                printToLog ('' + currentDateTime () + 'Setting old ItemGroups as inactive');
                id (ItemGroup g) <- 'old_' + id (g) WHERE g IS ItemGroup AND NOT new (g) AND NOT id (g) == 'All';
                inactive (ItemGroup g) <- TRUE WHERE g IS ItemGroup AND NOT new (g) AND NOT id (g) == 'All';
                setNoCancelInTransaction ();
                APPLY NESTED LOCAL;
                IF canceled () THEN {
                    printToLog ('' + currentDateTime () + 'ERROR' + applyMessage ());
                } ELSE {
                    printToLog ('' + currentDateTime () + 'Changing ids');
                    id (ItemGroup g) <- STRING [100] (replace (id (g), 'tst_', ''));
                    setNoCancelInTransaction ();
                    APPLY NESTED LOCAL;
                    IF canceled () THEN {
                        printToLog ('' + currentDateTime () + 'ERROR' + applyMessage ());
                    } ELSE formOk ();
                }
            }
        }
    } CATCH {
        printToLog ('' + currentDateTime () + 'ERROR' + messageCaughtException ());
    }
    
} CHANGEKEY 'ctrl ENTER';


// fillId 'Match by code' (CustomGroupType t) {
// itemGroup (CustomGroup g) <- itemGroup (id (g)) WHERE customGroupType (g) == t;
//}

EXTEND FORM replaceToItemGroupDialog
    PROPERTIES (t) overOkReplaceToItemGroupDialog //, fillId
;
DESIGN replaceToItemGroupDialog {
    TOOLBARRIGHT {
        REMOVE PROPERTY (formOk ());
        MOVE PROPERTY (overOkReplaceToItemGroupDialog (t)) BEFORE PROPERTY (formCancel ());
    }
}

replaceToItemGroup 'Replace main classifier' (CustomGroupType t) {
    IF (GROUP SUM 1 IF customGroupType (CustomGroup g) == t AND NOT id (g)) THEN {
        MESSAGE 'Code is not set for all groups of additional classifier';
        RETURN;
    }
    NEWSESSION SHOW replaceToItemGroupDialog;
}

EXTEND FORM customGroupTypes
    PROPERTIES TOOLBAR copyToCustomGroup () DRAW t, replaceToItemGroup (t)
;
DESIGN customGroupTypes {
    TOOLBARRIGHT (t) {
        MOVE PROPERTY (copyToCustomGroup ()) BEFORE TOOLBAR (t);
        MOVE PROPERTY (replaceToItemGroup (t)) AFTER PROPERTY (copyToCustomGroup ());
    }
}

@defineOption (copyBarcodeInItemId, 'Copy product barcode to code', items);

WHEN LOCAL CHANGED (barcode (Item i)) AND copyBarcodeInItemId () INLINE DO
    id (i) <- idBarcode (i);
    
needManufacturingDate 'Required manufacturing date' = ABSTRACT BOOLEAN (Sku);
needManufacturingDate (Barcode b) = needManufacturingDate (sku (b));
